// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod battlecode {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod schema {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ROBOT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ROBOT_TYPE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ROBOT_TYPE: [RobotType; 7] = [
  RobotType::NONE,
  RobotType::PAINT_TOWER,
  RobotType::MONEY_TOWER,
  RobotType::DEFENSE_TOWER,
  RobotType::SOLDIER,
  RobotType::SPLASHER,
  RobotType::MOPPER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RobotType(pub i8);
#[allow(non_upper_case_globals)]
impl RobotType {
  pub const NONE: Self = Self(0);
  pub const PAINT_TOWER: Self = Self(1);
  pub const MONEY_TOWER: Self = Self(2);
  pub const DEFENSE_TOWER: Self = Self(3);
  pub const SOLDIER: Self = Self(4);
  pub const SPLASHER: Self = Self(5);
  pub const MOPPER: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PAINT_TOWER,
    Self::MONEY_TOWER,
    Self::DEFENSE_TOWER,
    Self::SOLDIER,
    Self::SPLASHER,
    Self::MOPPER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PAINT_TOWER => Some("PAINT_TOWER"),
      Self::MONEY_TOWER => Some("MONEY_TOWER"),
      Self::DEFENSE_TOWER => Some("DEFENSE_TOWER"),
      Self::SOLDIER => Some("SOLDIER"),
      Self::SPLASHER => Some("SPLASHER"),
      Self::MOPPER => Some("MOPPER"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for RobotType {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RobotType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for RobotType {
    type Output = RobotType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for RobotType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RobotType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RobotType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_WIN_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_WIN_TYPE: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WIN_TYPE: [WinType; 9] = [
  WinType::RESIGNATION,
  WinType::MAJORITY_PAINTED,
  WinType::ALL_UNITS_DESTROYED,
  WinType::AREA_PAINTED,
  WinType::MORE_TOWERS,
  WinType::MORE_MONEY,
  WinType::MORE_STORED_PAINT,
  WinType::MORE_ROBOTS,
  WinType::COIN_FLIP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct WinType(pub i8);
#[allow(non_upper_case_globals)]
impl WinType {
  pub const RESIGNATION: Self = Self(0);
  pub const MAJORITY_PAINTED: Self = Self(1);
  pub const ALL_UNITS_DESTROYED: Self = Self(2);
  pub const AREA_PAINTED: Self = Self(3);
  pub const MORE_TOWERS: Self = Self(4);
  pub const MORE_MONEY: Self = Self(5);
  pub const MORE_STORED_PAINT: Self = Self(6);
  pub const MORE_ROBOTS: Self = Self(7);
  pub const COIN_FLIP: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RESIGNATION,
    Self::MAJORITY_PAINTED,
    Self::ALL_UNITS_DESTROYED,
    Self::AREA_PAINTED,
    Self::MORE_TOWERS,
    Self::MORE_MONEY,
    Self::MORE_STORED_PAINT,
    Self::MORE_ROBOTS,
    Self::COIN_FLIP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RESIGNATION => Some("RESIGNATION"),
      Self::MAJORITY_PAINTED => Some("MAJORITY_PAINTED"),
      Self::ALL_UNITS_DESTROYED => Some("ALL_UNITS_DESTROYED"),
      Self::AREA_PAINTED => Some("AREA_PAINTED"),
      Self::MORE_TOWERS => Some("MORE_TOWERS"),
      Self::MORE_MONEY => Some("MORE_MONEY"),
      Self::MORE_STORED_PAINT => Some("MORE_STORED_PAINT"),
      Self::MORE_ROBOTS => Some("MORE_ROBOTS"),
      Self::COIN_FLIP => Some("COIN_FLIP"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for WinType {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for WinType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for WinType {
    type Output = WinType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for WinType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for WinType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WinType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIE_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIE_TYPE: [DieType; 2] = [
  DieType::UNKNOWN,
  DieType::EXCEPTION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DieType(pub i8);
#[allow(non_upper_case_globals)]
impl DieType {
  pub const UNKNOWN: Self = Self(0);
  pub const EXCEPTION: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::EXCEPTION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNKNOWN => Some("UNKNOWN"),
      Self::EXCEPTION => Some("EXCEPTION"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for DieType {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DieType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for DieType {
    type Output = DieType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for DieType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DieType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DieType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ACTION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ACTION: u8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ACTION: [Action; 18] = [
  Action::NONE,
  Action::DamageAction,
  Action::PaintAction,
  Action::UnpaintAction,
  Action::MarkAction,
  Action::UnmarkAction,
  Action::AttackAction,
  Action::SplashAction,
  Action::MopAction,
  Action::BuildAction,
  Action::TransferAction,
  Action::MessageAction,
  Action::SpawnAction,
  Action::DieAction,
  Action::UpgradeAction,
  Action::IndicatorStringAction,
  Action::IndicatorDotAction,
  Action::IndicatorLineAction,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Action(pub u8);
#[allow(non_upper_case_globals)]
impl Action {
  pub const NONE: Self = Self(0);
  pub const DamageAction: Self = Self(1);
  pub const PaintAction: Self = Self(2);
  pub const UnpaintAction: Self = Self(3);
  pub const MarkAction: Self = Self(4);
  pub const UnmarkAction: Self = Self(5);
  pub const AttackAction: Self = Self(6);
  pub const SplashAction: Self = Self(7);
  pub const MopAction: Self = Self(8);
  pub const BuildAction: Self = Self(9);
  pub const TransferAction: Self = Self(10);
  pub const MessageAction: Self = Self(11);
  pub const SpawnAction: Self = Self(12);
  pub const DieAction: Self = Self(13);
  pub const UpgradeAction: Self = Self(14);
  pub const IndicatorStringAction: Self = Self(15);
  pub const IndicatorDotAction: Self = Self(16);
  pub const IndicatorLineAction: Self = Self(17);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DamageAction,
    Self::PaintAction,
    Self::UnpaintAction,
    Self::MarkAction,
    Self::UnmarkAction,
    Self::AttackAction,
    Self::SplashAction,
    Self::MopAction,
    Self::BuildAction,
    Self::TransferAction,
    Self::MessageAction,
    Self::SpawnAction,
    Self::DieAction,
    Self::UpgradeAction,
    Self::IndicatorStringAction,
    Self::IndicatorDotAction,
    Self::IndicatorLineAction,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::DamageAction => Some("DamageAction"),
      Self::PaintAction => Some("PaintAction"),
      Self::UnpaintAction => Some("UnpaintAction"),
      Self::MarkAction => Some("MarkAction"),
      Self::UnmarkAction => Some("UnmarkAction"),
      Self::AttackAction => Some("AttackAction"),
      Self::SplashAction => Some("SplashAction"),
      Self::MopAction => Some("MopAction"),
      Self::BuildAction => Some("BuildAction"),
      Self::TransferAction => Some("TransferAction"),
      Self::MessageAction => Some("MessageAction"),
      Self::SpawnAction => Some("SpawnAction"),
      Self::DieAction => Some("DieAction"),
      Self::UpgradeAction => Some("UpgradeAction"),
      Self::IndicatorStringAction => Some("IndicatorStringAction"),
      Self::IndicatorDotAction => Some("IndicatorDotAction"),
      Self::IndicatorLineAction => Some("IndicatorLineAction"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Action {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Action {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Action {
    type Output = Action;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Action {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Action {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Action {}
pub struct ActionUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EVENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EVENT: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT: [Event; 6] = [
  Event::NONE,
  Event::GameHeader,
  Event::MatchHeader,
  Event::Round,
  Event::MatchFooter,
  Event::GameFooter,
];

/// Events
/// An Event is a single step that needs to be processed.
/// A saved game simply consists of a long list of Events.
/// Events can be divided by either being sent separately (e.g. as separate
/// websocket messages), or by being wrapped with a GameWrapper.
/// A game consists of a series of matches; a match consists of a series of
/// rounds, and is played on a single map. Each round is a single simulation
/// step.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Event(pub u8);
#[allow(non_upper_case_globals)]
impl Event {
  pub const NONE: Self = Self(0);
  /// There should only be one GameHeader, at the start of the stream.
  pub const GameHeader: Self = Self(1);
  /// There should be one MatchHeader at the start of each match.
  pub const MatchHeader: Self = Self(2);
  /// A single simulation step. A round may be skipped if
  /// nothing happens during its time.
  pub const Round: Self = Self(3);
  /// There should be one MatchFooter at the end of each simulation step.
  pub const MatchFooter: Self = Self(4);
  /// There should only be one GameFooter, at the end of the stream.
  pub const GameFooter: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::GameHeader,
    Self::MatchHeader,
    Self::Round,
    Self::MatchFooter,
    Self::GameFooter,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::GameHeader => Some("GameHeader"),
      Self::MatchHeader => Some("MatchHeader"),
      Self::Round => Some("Round"),
      Self::MatchFooter => Some("MatchFooter"),
      Self::GameFooter => Some("GameFooter"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Event {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Event {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Event {
    type Output = Event;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Event {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Event {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Event {}
pub struct EventUnionTableOffset {}

// struct Vec, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec(pub [u8; 8]);
impl Default for Vec { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl std::fmt::Debug for Vec {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Vec")
      .field("x", &self.x())
      .field("y", &self.y())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec {}
impl flatbuffers::SafeSliceAccess for Vec {}
impl<'a> flatbuffers::Follow<'a> for Vec {
  type Inner = &'a Vec;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vec>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec {
  type Inner = &'a Vec;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vec>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vec {
    type Output = Vec;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Vec as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Vec {
    type Output = Vec;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Vec as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Vec {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: i32,
    y: i32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_x(x);
    s.set_y(y);
    s
  }

  pub fn x(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<i32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_x(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i32 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<i32>(),
      );
    }
  }

  pub fn y(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<i32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_y(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i32 as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<i32>(),
      );
    }
  }

}

pub enum VecTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VecTable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VecTable<'a> {
    type Inner = VecTable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> VecTable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        VecTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VecTableArgs<'args>) -> flatbuffers::WIPOffset<VecTable<'bldr>> {
      let mut builder = VecTableBuilder::new(_fbb);
      if let Some(x) = args.ys { builder.add_ys(x); }
      if let Some(x) = args.xs { builder.add_xs(x); }
      builder.finish()
    }

    pub const VT_XS: flatbuffers::VOffsetT = 4;
    pub const VT_YS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn xs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(VecTable::VT_XS, None)
  }
  #[inline]
  pub fn ys(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(VecTable::VT_YS, None)
  }
}

impl flatbuffers::Verifiable for VecTable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"xs", Self::VT_XS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"ys", Self::VT_YS, false)?
     .finish();
    Ok(())
  }
}
pub struct VecTableArgs<'a> {
    pub xs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub ys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for VecTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        VecTableArgs {
            xs: None,
            ys: None,
        }
    }
}
pub struct VecTableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VecTableBuilder<'a, 'b> {
  #[inline]
  pub fn add_xs(&mut self, xs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VecTable::VT_XS, xs);
  }
  #[inline]
  pub fn add_ys(&mut self, ys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VecTable::VT_YS, ys);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VecTableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VecTableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VecTable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for VecTable<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("VecTable");
      ds.field("xs", &self.xs());
      ds.field("ys", &self.ys());
      ds.finish()
  }
}
pub enum RobotTypeMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RobotTypeMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RobotTypeMetadata<'a> {
    type Inner = RobotTypeMetadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RobotTypeMetadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RobotTypeMetadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RobotTypeMetadataArgs) -> flatbuffers::WIPOffset<RobotTypeMetadata<'bldr>> {
      let mut builder = RobotTypeMetadataBuilder::new(_fbb);
      builder.add_bytecode_limit(args.bytecode_limit);
      builder.add_message_radius_squared(args.message_radius_squared);
      builder.add_vision_radius_squared(args.vision_radius_squared);
      builder.add_action_radius_squared(args.action_radius_squared);
      builder.add_max_paint(args.max_paint);
      builder.add_base_paint(args.base_paint);
      builder.add_base_health(args.base_health);
      builder.add_movement_cooldown(args.movement_cooldown);
      builder.add_action_cooldown(args.action_cooldown);
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ACTION_COOLDOWN: flatbuffers::VOffsetT = 6;
    pub const VT_MOVEMENT_COOLDOWN: flatbuffers::VOffsetT = 8;
    pub const VT_BASE_HEALTH: flatbuffers::VOffsetT = 10;
    pub const VT_BASE_PAINT: flatbuffers::VOffsetT = 12;
    pub const VT_MAX_PAINT: flatbuffers::VOffsetT = 14;
    pub const VT_ACTION_RADIUS_SQUARED: flatbuffers::VOffsetT = 16;
    pub const VT_VISION_RADIUS_SQUARED: flatbuffers::VOffsetT = 18;
    pub const VT_MESSAGE_RADIUS_SQUARED: flatbuffers::VOffsetT = 20;
    pub const VT_BYTECODE_LIMIT: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn type_(&self) -> RobotType {
    self._tab.get::<RobotType>(RobotTypeMetadata::VT_TYPE_, Some(RobotType::NONE)).unwrap()
  }
  #[inline]
  pub fn action_cooldown(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_ACTION_COOLDOWN, Some(0)).unwrap()
  }
  #[inline]
  pub fn movement_cooldown(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_MOVEMENT_COOLDOWN, Some(0)).unwrap()
  }
  #[inline]
  pub fn base_health(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_BASE_HEALTH, Some(0)).unwrap()
  }
  #[inline]
  pub fn base_paint(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_BASE_PAINT, Some(0)).unwrap()
  }
  #[inline]
  pub fn max_paint(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_MAX_PAINT, Some(0)).unwrap()
  }
  #[inline]
  pub fn action_radius_squared(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_ACTION_RADIUS_SQUARED, Some(0)).unwrap()
  }
  #[inline]
  pub fn vision_radius_squared(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_VISION_RADIUS_SQUARED, Some(0)).unwrap()
  }
  #[inline]
  pub fn message_radius_squared(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_MESSAGE_RADIUS_SQUARED, Some(0)).unwrap()
  }
  #[inline]
  pub fn bytecode_limit(&self) -> i32 {
    self._tab.get::<i32>(RobotTypeMetadata::VT_BYTECODE_LIMIT, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for RobotTypeMetadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<RobotType>(&"type_", Self::VT_TYPE_, false)?
     .visit_field::<i32>(&"action_cooldown", Self::VT_ACTION_COOLDOWN, false)?
     .visit_field::<i32>(&"movement_cooldown", Self::VT_MOVEMENT_COOLDOWN, false)?
     .visit_field::<i32>(&"base_health", Self::VT_BASE_HEALTH, false)?
     .visit_field::<i32>(&"base_paint", Self::VT_BASE_PAINT, false)?
     .visit_field::<i32>(&"max_paint", Self::VT_MAX_PAINT, false)?
     .visit_field::<i32>(&"action_radius_squared", Self::VT_ACTION_RADIUS_SQUARED, false)?
     .visit_field::<i32>(&"vision_radius_squared", Self::VT_VISION_RADIUS_SQUARED, false)?
     .visit_field::<i32>(&"message_radius_squared", Self::VT_MESSAGE_RADIUS_SQUARED, false)?
     .visit_field::<i32>(&"bytecode_limit", Self::VT_BYTECODE_LIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct RobotTypeMetadataArgs {
    pub type_: RobotType,
    pub action_cooldown: i32,
    pub movement_cooldown: i32,
    pub base_health: i32,
    pub base_paint: i32,
    pub max_paint: i32,
    pub action_radius_squared: i32,
    pub vision_radius_squared: i32,
    pub message_radius_squared: i32,
    pub bytecode_limit: i32,
}
impl<'a> Default for RobotTypeMetadataArgs {
    #[inline]
    fn default() -> Self {
        RobotTypeMetadataArgs {
            type_: RobotType::NONE,
            action_cooldown: 0,
            movement_cooldown: 0,
            base_health: 0,
            base_paint: 0,
            max_paint: 0,
            action_radius_squared: 0,
            vision_radius_squared: 0,
            message_radius_squared: 0,
            bytecode_limit: 0,
        }
    }
}
pub struct RobotTypeMetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RobotTypeMetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: RobotType) {
    self.fbb_.push_slot::<RobotType>(RobotTypeMetadata::VT_TYPE_, type_, RobotType::NONE);
  }
  #[inline]
  pub fn add_action_cooldown(&mut self, action_cooldown: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_ACTION_COOLDOWN, action_cooldown, 0);
  }
  #[inline]
  pub fn add_movement_cooldown(&mut self, movement_cooldown: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_MOVEMENT_COOLDOWN, movement_cooldown, 0);
  }
  #[inline]
  pub fn add_base_health(&mut self, base_health: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_BASE_HEALTH, base_health, 0);
  }
  #[inline]
  pub fn add_base_paint(&mut self, base_paint: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_BASE_PAINT, base_paint, 0);
  }
  #[inline]
  pub fn add_max_paint(&mut self, max_paint: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_MAX_PAINT, max_paint, 0);
  }
  #[inline]
  pub fn add_action_radius_squared(&mut self, action_radius_squared: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_ACTION_RADIUS_SQUARED, action_radius_squared, 0);
  }
  #[inline]
  pub fn add_vision_radius_squared(&mut self, vision_radius_squared: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_VISION_RADIUS_SQUARED, vision_radius_squared, 0);
  }
  #[inline]
  pub fn add_message_radius_squared(&mut self, message_radius_squared: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_MESSAGE_RADIUS_SQUARED, message_radius_squared, 0);
  }
  #[inline]
  pub fn add_bytecode_limit(&mut self, bytecode_limit: i32) {
    self.fbb_.push_slot::<i32>(RobotTypeMetadata::VT_BYTECODE_LIMIT, bytecode_limit, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RobotTypeMetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RobotTypeMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RobotTypeMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RobotTypeMetadata<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RobotTypeMetadata");
      ds.field("type_", &self.type_());
      ds.field("action_cooldown", &self.action_cooldown());
      ds.field("movement_cooldown", &self.movement_cooldown());
      ds.field("base_health", &self.base_health());
      ds.field("base_paint", &self.base_paint());
      ds.field("max_paint", &self.max_paint());
      ds.field("action_radius_squared", &self.action_radius_squared());
      ds.field("vision_radius_squared", &self.vision_radius_squared());
      ds.field("message_radius_squared", &self.message_radius_squared());
      ds.field("bytecode_limit", &self.bytecode_limit());
      ds.finish()
  }
}
pub enum TeamDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TeamData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TeamData<'a> {
    type Inner = TeamData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TeamData<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TeamData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TeamDataArgs<'args>) -> flatbuffers::WIPOffset<TeamData<'bldr>> {
      let mut builder = TeamDataBuilder::new(_fbb);
      if let Some(x) = args.package_name { builder.add_package_name(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_team_id(args.team_id);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_PACKAGE_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_TEAM_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TeamData::VT_NAME, None)
  }
  #[inline]
  pub fn package_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TeamData::VT_PACKAGE_NAME, None)
  }
  #[inline]
  pub fn team_id(&self) -> i8 {
    self._tab.get::<i8>(TeamData::VT_TEAM_ID, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for TeamData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"package_name", Self::VT_PACKAGE_NAME, false)?
     .visit_field::<i8>(&"team_id", Self::VT_TEAM_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct TeamDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub package_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub team_id: i8,
}
impl<'a> Default for TeamDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        TeamDataArgs {
            name: None,
            package_name: None,
            team_id: 0,
        }
    }
}
pub struct TeamDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TeamDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TeamData::VT_NAME, name);
  }
  #[inline]
  pub fn add_package_name(&mut self, package_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TeamData::VT_PACKAGE_NAME, package_name);
  }
  #[inline]
  pub fn add_team_id(&mut self, team_id: i8) {
    self.fbb_.push_slot::<i8>(TeamData::VT_TEAM_ID, team_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TeamDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TeamDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TeamData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TeamData<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TeamData");
      ds.field("name", &self.name());
      ds.field("package_name", &self.package_name());
      ds.field("team_id", &self.team_id());
      ds.finish()
  }
}
pub enum GameplayConstantsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GameplayConstants<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GameplayConstants<'a> {
    type Inner = GameplayConstants<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> GameplayConstants<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GameplayConstants { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args GameplayConstantsArgs) -> flatbuffers::WIPOffset<GameplayConstants<'bldr>> {
      let mut builder = GameplayConstantsBuilder::new(_fbb);
      builder.finish()
    }

}

impl flatbuffers::Verifiable for GameplayConstants<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GameplayConstantsArgs {
}
impl<'a> Default for GameplayConstantsArgs {
    #[inline]
    fn default() -> Self {
        GameplayConstantsArgs {
        }
    }
}
pub struct GameplayConstantsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GameplayConstantsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GameplayConstantsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GameplayConstantsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GameplayConstants<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for GameplayConstants<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("GameplayConstants");
      ds.finish()
  }
}
pub enum DamageActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Generic action representing damage to a robot
pub struct DamageAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DamageAction<'a> {
    type Inner = DamageAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> DamageAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DamageAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DamageActionArgs) -> flatbuffers::WIPOffset<DamageAction<'bldr>> {
      let mut builder = DamageActionBuilder::new(_fbb);
      builder.add_damage(args.damage);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DAMAGE: flatbuffers::VOffsetT = 6;

  /// Id of the damage target
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(DamageAction::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn damage(&self) -> u16 {
    self._tab.get::<u16>(DamageAction::VT_DAMAGE, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for DamageAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .visit_field::<u16>(&"damage", Self::VT_DAMAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct DamageActionArgs {
    pub id: u16,
    pub damage: u16,
}
impl<'a> Default for DamageActionArgs {
    #[inline]
    fn default() -> Self {
        DamageActionArgs {
            id: 0,
            damage: 0,
        }
    }
}
pub struct DamageActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DamageActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(DamageAction::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_damage(&mut self, damage: u16) {
    self.fbb_.push_slot::<u16>(DamageAction::VT_DAMAGE, damage, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DamageActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DamageActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DamageAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for DamageAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("DamageAction");
      ds.field("id", &self.id());
      ds.field("damage", &self.damage());
      ds.finish()
  }
}
pub enum PaintActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate a tile has been painted
pub struct PaintAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PaintAction<'a> {
    type Inner = PaintAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> PaintAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PaintAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PaintActionArgs) -> flatbuffers::WIPOffset<PaintAction<'bldr>> {
      let mut builder = PaintActionBuilder::new(_fbb);
      builder.add_loc(args.loc);
      builder.add_is_secondary(args.is_secondary);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_IS_SECONDARY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> u16 {
    self._tab.get::<u16>(PaintAction::VT_LOC, Some(0)).unwrap()
  }
  #[inline]
  pub fn is_secondary(&self) -> i8 {
    self._tab.get::<i8>(PaintAction::VT_IS_SECONDARY, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for PaintAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"loc", Self::VT_LOC, false)?
     .visit_field::<i8>(&"is_secondary", Self::VT_IS_SECONDARY, false)?
     .finish();
    Ok(())
  }
}
pub struct PaintActionArgs {
    pub loc: u16,
    pub is_secondary: i8,
}
impl<'a> Default for PaintActionArgs {
    #[inline]
    fn default() -> Self {
        PaintActionArgs {
            loc: 0,
            is_secondary: 0,
        }
    }
}
pub struct PaintActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PaintActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: u16) {
    self.fbb_.push_slot::<u16>(PaintAction::VT_LOC, loc, 0);
  }
  #[inline]
  pub fn add_is_secondary(&mut self, is_secondary: i8) {
    self.fbb_.push_slot::<i8>(PaintAction::VT_IS_SECONDARY, is_secondary, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PaintActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PaintActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PaintAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for PaintAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("PaintAction");
      ds.field("loc", &self.loc());
      ds.field("is_secondary", &self.is_secondary());
      ds.finish()
  }
}
pub enum UnpaintActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate a tile's paint has been removed
pub struct UnpaintAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnpaintAction<'a> {
    type Inner = UnpaintAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UnpaintAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnpaintAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnpaintActionArgs) -> flatbuffers::WIPOffset<UnpaintAction<'bldr>> {
      let mut builder = UnpaintActionBuilder::new(_fbb);
      builder.add_loc(args.loc);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn loc(&self) -> u16 {
    self._tab.get::<u16>(UnpaintAction::VT_LOC, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for UnpaintAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"loc", Self::VT_LOC, false)?
     .finish();
    Ok(())
  }
}
pub struct UnpaintActionArgs {
    pub loc: u16,
}
impl<'a> Default for UnpaintActionArgs {
    #[inline]
    fn default() -> Self {
        UnpaintActionArgs {
            loc: 0,
        }
    }
}
pub struct UnpaintActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnpaintActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: u16) {
    self.fbb_.push_slot::<u16>(UnpaintAction::VT_LOC, loc, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnpaintActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnpaintActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnpaintAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UnpaintAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UnpaintAction");
      ds.field("loc", &self.loc());
      ds.finish()
  }
}
pub enum MarkActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate a tile marked with a color
pub struct MarkAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MarkAction<'a> {
    type Inner = MarkAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MarkAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MarkAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MarkActionArgs) -> flatbuffers::WIPOffset<MarkAction<'bldr>> {
      let mut builder = MarkActionBuilder::new(_fbb);
      builder.add_loc(args.loc);
      builder.add_is_secondary(args.is_secondary);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_IS_SECONDARY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> u16 {
    self._tab.get::<u16>(MarkAction::VT_LOC, Some(0)).unwrap()
  }
  #[inline]
  pub fn is_secondary(&self) -> i8 {
    self._tab.get::<i8>(MarkAction::VT_IS_SECONDARY, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for MarkAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"loc", Self::VT_LOC, false)?
     .visit_field::<i8>(&"is_secondary", Self::VT_IS_SECONDARY, false)?
     .finish();
    Ok(())
  }
}
pub struct MarkActionArgs {
    pub loc: u16,
    pub is_secondary: i8,
}
impl<'a> Default for MarkActionArgs {
    #[inline]
    fn default() -> Self {
        MarkActionArgs {
            loc: 0,
            is_secondary: 0,
        }
    }
}
pub struct MarkActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MarkActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: u16) {
    self.fbb_.push_slot::<u16>(MarkAction::VT_LOC, loc, 0);
  }
  #[inline]
  pub fn add_is_secondary(&mut self, is_secondary: i8) {
    self.fbb_.push_slot::<i8>(MarkAction::VT_IS_SECONDARY, is_secondary, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MarkActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MarkActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MarkAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MarkAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MarkAction");
      ds.field("loc", &self.loc());
      ds.field("is_secondary", &self.is_secondary());
      ds.finish()
  }
}
pub enum UnmarkActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate a tile's marker has been removed
pub struct UnmarkAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnmarkAction<'a> {
    type Inner = UnmarkAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UnmarkAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnmarkAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnmarkActionArgs) -> flatbuffers::WIPOffset<UnmarkAction<'bldr>> {
      let mut builder = UnmarkActionBuilder::new(_fbb);
      builder.add_loc(args.loc);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn loc(&self) -> u16 {
    self._tab.get::<u16>(UnmarkAction::VT_LOC, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for UnmarkAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"loc", Self::VT_LOC, false)?
     .finish();
    Ok(())
  }
}
pub struct UnmarkActionArgs {
    pub loc: u16,
}
impl<'a> Default for UnmarkActionArgs {
    #[inline]
    fn default() -> Self {
        UnmarkActionArgs {
            loc: 0,
        }
    }
}
pub struct UnmarkActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnmarkActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: u16) {
    self.fbb_.push_slot::<u16>(UnmarkAction::VT_LOC, loc, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnmarkActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnmarkActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnmarkAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UnmarkAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UnmarkAction");
      ds.field("loc", &self.loc());
      ds.finish()
  }
}
pub enum AttackActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate an attack
pub struct AttackAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AttackAction<'a> {
    type Inner = AttackAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> AttackAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AttackAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AttackActionArgs) -> flatbuffers::WIPOffset<AttackAction<'bldr>> {
      let mut builder = AttackActionBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  /// Id of the attack target
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(AttackAction::VT_ID, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for AttackAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct AttackActionArgs {
    pub id: u16,
}
impl<'a> Default for AttackActionArgs {
    #[inline]
    fn default() -> Self {
        AttackActionArgs {
            id: 0,
        }
    }
}
pub struct AttackActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AttackActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(AttackAction::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AttackActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AttackActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AttackAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for AttackAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("AttackAction");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum SplashActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate a splash attack
pub struct SplashAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplashAction<'a> {
    type Inner = SplashAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SplashAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SplashAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SplashActionArgs) -> flatbuffers::WIPOffset<SplashAction<'bldr>> {
      let mut builder = SplashActionBuilder::new(_fbb);
      builder.add_loc(args.loc);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;

  /// Location of the splash attack
  #[inline]
  pub fn loc(&self) -> u16 {
    self._tab.get::<u16>(SplashAction::VT_LOC, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for SplashAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"loc", Self::VT_LOC, false)?
     .finish();
    Ok(())
  }
}
pub struct SplashActionArgs {
    pub loc: u16,
}
impl<'a> Default for SplashActionArgs {
    #[inline]
    fn default() -> Self {
        SplashActionArgs {
            loc: 0,
        }
    }
}
pub struct SplashActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplashActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: u16) {
    self.fbb_.push_slot::<u16>(SplashAction::VT_LOC, loc, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplashActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SplashActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SplashAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SplashAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SplashAction");
      ds.field("loc", &self.loc());
      ds.finish()
  }
}
pub enum MopActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate a mop attack
pub struct MopAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MopAction<'a> {
    type Inner = MopAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MopAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MopAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MopActionArgs) -> flatbuffers::WIPOffset<MopAction<'bldr>> {
      let mut builder = MopActionBuilder::new(_fbb);
      builder.add_id2(args.id2);
      builder.add_id1(args.id1);
      builder.add_id0(args.id0);
      builder.finish()
    }

    pub const VT_ID0: flatbuffers::VOffsetT = 4;
    pub const VT_ID1: flatbuffers::VOffsetT = 6;
    pub const VT_ID2: flatbuffers::VOffsetT = 8;

  /// Ids of the mopped targets, possibly 0
  #[inline]
  pub fn id0(&self) -> u16 {
    self._tab.get::<u16>(MopAction::VT_ID0, Some(0)).unwrap()
  }
  #[inline]
  pub fn id1(&self) -> u16 {
    self._tab.get::<u16>(MopAction::VT_ID1, Some(0)).unwrap()
  }
  #[inline]
  pub fn id2(&self) -> u16 {
    self._tab.get::<u16>(MopAction::VT_ID2, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for MopAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id0", Self::VT_ID0, false)?
     .visit_field::<u16>(&"id1", Self::VT_ID1, false)?
     .visit_field::<u16>(&"id2", Self::VT_ID2, false)?
     .finish();
    Ok(())
  }
}
pub struct MopActionArgs {
    pub id0: u16,
    pub id1: u16,
    pub id2: u16,
}
impl<'a> Default for MopActionArgs {
    #[inline]
    fn default() -> Self {
        MopActionArgs {
            id0: 0,
            id1: 0,
            id2: 0,
        }
    }
}
pub struct MopActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MopActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id0(&mut self, id0: u16) {
    self.fbb_.push_slot::<u16>(MopAction::VT_ID0, id0, 0);
  }
  #[inline]
  pub fn add_id1(&mut self, id1: u16) {
    self.fbb_.push_slot::<u16>(MopAction::VT_ID1, id1, 0);
  }
  #[inline]
  pub fn add_id2(&mut self, id2: u16) {
    self.fbb_.push_slot::<u16>(MopAction::VT_ID2, id2, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MopActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MopActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MopAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MopAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MopAction");
      ds.field("id0", &self.id0());
      ds.field("id1", &self.id1());
      ds.field("id2", &self.id2());
      ds.finish()
  }
}
pub enum BuildActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate a tower being built
pub struct BuildAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BuildAction<'a> {
    type Inner = BuildAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> BuildAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BuildAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BuildActionArgs) -> flatbuffers::WIPOffset<BuildAction<'bldr>> {
      let mut builder = BuildActionBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  /// Id of the tower bot
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(BuildAction::VT_ID, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for BuildAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct BuildActionArgs {
    pub id: u16,
}
impl<'a> Default for BuildActionArgs {
    #[inline]
    fn default() -> Self {
        BuildActionArgs {
            id: 0,
        }
    }
}
pub struct BuildActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BuildActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(BuildAction::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BuildActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BuildActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BuildAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for BuildAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("BuildAction");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum TransferActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate transferring paint from one robot to another
pub struct TransferAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransferAction<'a> {
    type Inner = TransferAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TransferAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransferAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransferActionArgs) -> flatbuffers::WIPOffset<TransferAction<'bldr>> {
      let mut builder = TransferActionBuilder::new(_fbb);
      builder.add_amount(args.amount);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;

  /// Id of the transfer target
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(TransferAction::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn amount(&self) -> i32 {
    self._tab.get::<i32>(TransferAction::VT_AMOUNT, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for TransferAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .visit_field::<i32>(&"amount", Self::VT_AMOUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct TransferActionArgs {
    pub id: u16,
    pub amount: i32,
}
impl<'a> Default for TransferActionArgs {
    #[inline]
    fn default() -> Self {
        TransferActionArgs {
            id: 0,
            amount: 0,
        }
    }
}
pub struct TransferActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransferActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(TransferAction::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: i32) {
    self.fbb_.push_slot::<i32>(TransferAction::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransferActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransferActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransferAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TransferAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TransferAction");
      ds.field("id", &self.id());
      ds.field("amount", &self.amount());
      ds.finish()
  }
}
pub enum MessageActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate messaging from one robot to another
pub struct MessageAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MessageAction<'a> {
    type Inner = MessageAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MessageAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MessageAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageActionArgs) -> flatbuffers::WIPOffset<MessageAction<'bldr>> {
      let mut builder = MessageActionBuilder::new(_fbb);
      builder.add_data(args.data);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

  /// Id of the message target
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(MessageAction::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> i32 {
    self._tab.get::<i32>(MessageAction::VT_DATA, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for MessageAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .visit_field::<i32>(&"data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageActionArgs {
    pub id: u16,
    pub data: i32,
}
impl<'a> Default for MessageActionArgs {
    #[inline]
    fn default() -> Self {
        MessageActionArgs {
            id: 0,
            data: 0,
        }
    }
}
pub struct MessageActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(MessageAction::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: i32) {
    self.fbb_.push_slot::<i32>(MessageAction::VT_DATA, data, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MessageAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MessageAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MessageAction");
      ds.field("id", &self.id());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum SpawnActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Indicate that this robot was spawned on this turn
pub struct SpawnAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpawnAction<'a> {
    type Inner = SpawnAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SpawnAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SpawnAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SpawnActionArgs) -> flatbuffers::WIPOffset<SpawnAction<'bldr>> {
      let mut builder = SpawnActionBuilder::new(_fbb);
      builder.add_y(args.y);
      builder.add_x(args.x);
      builder.add_id(args.id);
      builder.add_robot_type(args.robot_type);
      builder.add_team(args.team);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_X: flatbuffers::VOffsetT = 6;
    pub const VT_Y: flatbuffers::VOffsetT = 8;
    pub const VT_TEAM: flatbuffers::VOffsetT = 10;
    pub const VT_ROBOT_TYPE: flatbuffers::VOffsetT = 12;

  /// Id of the bot that spawned
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(SpawnAction::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn x(&self) -> u16 {
    self._tab.get::<u16>(SpawnAction::VT_X, Some(0)).unwrap()
  }
  #[inline]
  pub fn y(&self) -> u16 {
    self._tab.get::<u16>(SpawnAction::VT_Y, Some(0)).unwrap()
  }
  #[inline]
  pub fn team(&self) -> i8 {
    self._tab.get::<i8>(SpawnAction::VT_TEAM, Some(0)).unwrap()
  }
  #[inline]
  pub fn robot_type(&self) -> RobotType {
    self._tab.get::<RobotType>(SpawnAction::VT_ROBOT_TYPE, Some(RobotType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for SpawnAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .visit_field::<u16>(&"x", Self::VT_X, false)?
     .visit_field::<u16>(&"y", Self::VT_Y, false)?
     .visit_field::<i8>(&"team", Self::VT_TEAM, false)?
     .visit_field::<RobotType>(&"robot_type", Self::VT_ROBOT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct SpawnActionArgs {
    pub id: u16,
    pub x: u16,
    pub y: u16,
    pub team: i8,
    pub robot_type: RobotType,
}
impl<'a> Default for SpawnActionArgs {
    #[inline]
    fn default() -> Self {
        SpawnActionArgs {
            id: 0,
            x: 0,
            y: 0,
            team: 0,
            robot_type: RobotType::NONE,
        }
    }
}
pub struct SpawnActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpawnActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(SpawnAction::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_x(&mut self, x: u16) {
    self.fbb_.push_slot::<u16>(SpawnAction::VT_X, x, 0);
  }
  #[inline]
  pub fn add_y(&mut self, y: u16) {
    self.fbb_.push_slot::<u16>(SpawnAction::VT_Y, y, 0);
  }
  #[inline]
  pub fn add_team(&mut self, team: i8) {
    self.fbb_.push_slot::<i8>(SpawnAction::VT_TEAM, team, 0);
  }
  #[inline]
  pub fn add_robot_type(&mut self, robot_type: RobotType) {
    self.fbb_.push_slot::<RobotType>(SpawnAction::VT_ROBOT_TYPE, robot_type, RobotType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpawnActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpawnActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpawnAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SpawnAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SpawnAction");
      ds.field("id", &self.id());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("team", &self.team());
      ds.field("robot_type", &self.robot_type());
      ds.finish()
  }
}
pub enum DieActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Indicates that a robot died and should be removed
pub struct DieAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DieAction<'a> {
    type Inner = DieAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> DieAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DieAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DieActionArgs) -> flatbuffers::WIPOffset<DieAction<'bldr>> {
      let mut builder = DieActionBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.add_die_type(args.die_type);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DIE_TYPE: flatbuffers::VOffsetT = 6;

  /// Id of the robot that died
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(DieAction::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn die_type(&self) -> DieType {
    self._tab.get::<DieType>(DieAction::VT_DIE_TYPE, Some(DieType::UNKNOWN)).unwrap()
  }
}

impl flatbuffers::Verifiable for DieAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .visit_field::<DieType>(&"die_type", Self::VT_DIE_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct DieActionArgs {
    pub id: u16,
    pub die_type: DieType,
}
impl<'a> Default for DieActionArgs {
    #[inline]
    fn default() -> Self {
        DieActionArgs {
            id: 0,
            die_type: DieType::UNKNOWN,
        }
    }
}
pub struct DieActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DieActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(DieAction::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_die_type(&mut self, die_type: DieType) {
    self.fbb_.push_slot::<DieType>(DieAction::VT_DIE_TYPE, die_type, DieType::UNKNOWN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DieActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DieActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DieAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for DieAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("DieAction");
      ds.field("id", &self.id());
      ds.field("die_type", &self.die_type());
      ds.finish()
  }
}
pub enum UpgradeActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Visually indicate that a tower was upgraded
pub struct UpgradeAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpgradeAction<'a> {
    type Inner = UpgradeAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> UpgradeAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UpgradeAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UpgradeActionArgs) -> flatbuffers::WIPOffset<UpgradeAction<'bldr>> {
      let mut builder = UpgradeActionBuilder::new(_fbb);
      builder.add_new_max_paint(args.new_max_paint);
      builder.add_new_paint(args.new_paint);
      builder.add_new_max_health(args.new_max_health);
      builder.add_new_health(args.new_health);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NEW_HEALTH: flatbuffers::VOffsetT = 6;
    pub const VT_NEW_MAX_HEALTH: flatbuffers::VOffsetT = 8;
    pub const VT_NEW_PAINT: flatbuffers::VOffsetT = 10;
    pub const VT_NEW_MAX_PAINT: flatbuffers::VOffsetT = 12;

  /// Id of the upgraded tower
  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(UpgradeAction::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn new_health(&self) -> i32 {
    self._tab.get::<i32>(UpgradeAction::VT_NEW_HEALTH, Some(0)).unwrap()
  }
  #[inline]
  pub fn new_max_health(&self) -> i32 {
    self._tab.get::<i32>(UpgradeAction::VT_NEW_MAX_HEALTH, Some(0)).unwrap()
  }
  #[inline]
  pub fn new_paint(&self) -> i32 {
    self._tab.get::<i32>(UpgradeAction::VT_NEW_PAINT, Some(0)).unwrap()
  }
  #[inline]
  pub fn new_max_paint(&self) -> i32 {
    self._tab.get::<i32>(UpgradeAction::VT_NEW_MAX_PAINT, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for UpgradeAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"id", Self::VT_ID, false)?
     .visit_field::<i32>(&"new_health", Self::VT_NEW_HEALTH, false)?
     .visit_field::<i32>(&"new_max_health", Self::VT_NEW_MAX_HEALTH, false)?
     .visit_field::<i32>(&"new_paint", Self::VT_NEW_PAINT, false)?
     .visit_field::<i32>(&"new_max_paint", Self::VT_NEW_MAX_PAINT, false)?
     .finish();
    Ok(())
  }
}
pub struct UpgradeActionArgs {
    pub id: u16,
    pub new_health: i32,
    pub new_max_health: i32,
    pub new_paint: i32,
    pub new_max_paint: i32,
}
impl<'a> Default for UpgradeActionArgs {
    #[inline]
    fn default() -> Self {
        UpgradeActionArgs {
            id: 0,
            new_health: 0,
            new_max_health: 0,
            new_paint: 0,
            new_max_paint: 0,
        }
    }
}
pub struct UpgradeActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpgradeActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(UpgradeAction::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_new_health(&mut self, new_health: i32) {
    self.fbb_.push_slot::<i32>(UpgradeAction::VT_NEW_HEALTH, new_health, 0);
  }
  #[inline]
  pub fn add_new_max_health(&mut self, new_max_health: i32) {
    self.fbb_.push_slot::<i32>(UpgradeAction::VT_NEW_MAX_HEALTH, new_max_health, 0);
  }
  #[inline]
  pub fn add_new_paint(&mut self, new_paint: i32) {
    self.fbb_.push_slot::<i32>(UpgradeAction::VT_NEW_PAINT, new_paint, 0);
  }
  #[inline]
  pub fn add_new_max_paint(&mut self, new_max_paint: i32) {
    self.fbb_.push_slot::<i32>(UpgradeAction::VT_NEW_MAX_PAINT, new_max_paint, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpgradeActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpgradeActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpgradeAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for UpgradeAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("UpgradeAction");
      ds.field("id", &self.id());
      ds.field("new_health", &self.new_health());
      ds.field("new_max_health", &self.new_max_health());
      ds.field("new_paint", &self.new_paint());
      ds.field("new_max_paint", &self.new_max_paint());
      ds.finish()
  }
}
pub enum IndicatorStringActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Update the indicator string for this robot
pub struct IndicatorStringAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IndicatorStringAction<'a> {
    type Inner = IndicatorStringAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> IndicatorStringAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IndicatorStringAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IndicatorStringActionArgs<'args>) -> flatbuffers::WIPOffset<IndicatorStringAction<'bldr>> {
      let mut builder = IndicatorStringActionBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      builder.finish()
    }

    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IndicatorStringAction::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for IndicatorStringAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct IndicatorStringActionArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for IndicatorStringActionArgs<'a> {
    #[inline]
    fn default() -> Self {
        IndicatorStringActionArgs {
            value: None,
        }
    }
}
pub struct IndicatorStringActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IndicatorStringActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IndicatorStringAction::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IndicatorStringActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IndicatorStringActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IndicatorStringAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for IndicatorStringAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("IndicatorStringAction");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum IndicatorDotActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Update the indicator dot for this robot
pub struct IndicatorDotAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IndicatorDotAction<'a> {
    type Inner = IndicatorDotAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> IndicatorDotAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IndicatorDotAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IndicatorDotActionArgs) -> flatbuffers::WIPOffset<IndicatorDotAction<'bldr>> {
      let mut builder = IndicatorDotActionBuilder::new(_fbb);
      builder.add_color_hex(args.color_hex);
      builder.add_loc(args.loc);
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_COLOR_HEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> u16 {
    self._tab.get::<u16>(IndicatorDotAction::VT_LOC, Some(0)).unwrap()
  }
  #[inline]
  pub fn color_hex(&self) -> i32 {
    self._tab.get::<i32>(IndicatorDotAction::VT_COLOR_HEX, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for IndicatorDotAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"loc", Self::VT_LOC, false)?
     .visit_field::<i32>(&"color_hex", Self::VT_COLOR_HEX, false)?
     .finish();
    Ok(())
  }
}
pub struct IndicatorDotActionArgs {
    pub loc: u16,
    pub color_hex: i32,
}
impl<'a> Default for IndicatorDotActionArgs {
    #[inline]
    fn default() -> Self {
        IndicatorDotActionArgs {
            loc: 0,
            color_hex: 0,
        }
    }
}
pub struct IndicatorDotActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IndicatorDotActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: u16) {
    self.fbb_.push_slot::<u16>(IndicatorDotAction::VT_LOC, loc, 0);
  }
  #[inline]
  pub fn add_color_hex(&mut self, color_hex: i32) {
    self.fbb_.push_slot::<i32>(IndicatorDotAction::VT_COLOR_HEX, color_hex, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IndicatorDotActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IndicatorDotActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IndicatorDotAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for IndicatorDotAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("IndicatorDotAction");
      ds.field("loc", &self.loc());
      ds.field("color_hex", &self.color_hex());
      ds.finish()
  }
}
pub enum IndicatorLineActionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Update the indicator line for this robot
pub struct IndicatorLineAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IndicatorLineAction<'a> {
    type Inner = IndicatorLineAction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> IndicatorLineAction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IndicatorLineAction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IndicatorLineActionArgs) -> flatbuffers::WIPOffset<IndicatorLineAction<'bldr>> {
      let mut builder = IndicatorLineActionBuilder::new(_fbb);
      builder.add_color_hex(args.color_hex);
      builder.add_end_loc(args.end_loc);
      builder.add_start_loc(args.start_loc);
      builder.finish()
    }

    pub const VT_START_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_END_LOC: flatbuffers::VOffsetT = 6;
    pub const VT_COLOR_HEX: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn start_loc(&self) -> u16 {
    self._tab.get::<u16>(IndicatorLineAction::VT_START_LOC, Some(0)).unwrap()
  }
  #[inline]
  pub fn end_loc(&self) -> u16 {
    self._tab.get::<u16>(IndicatorLineAction::VT_END_LOC, Some(0)).unwrap()
  }
  #[inline]
  pub fn color_hex(&self) -> i32 {
    self._tab.get::<i32>(IndicatorLineAction::VT_COLOR_HEX, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for IndicatorLineAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"start_loc", Self::VT_START_LOC, false)?
     .visit_field::<u16>(&"end_loc", Self::VT_END_LOC, false)?
     .visit_field::<i32>(&"color_hex", Self::VT_COLOR_HEX, false)?
     .finish();
    Ok(())
  }
}
pub struct IndicatorLineActionArgs {
    pub start_loc: u16,
    pub end_loc: u16,
    pub color_hex: i32,
}
impl<'a> Default for IndicatorLineActionArgs {
    #[inline]
    fn default() -> Self {
        IndicatorLineActionArgs {
            start_loc: 0,
            end_loc: 0,
            color_hex: 0,
        }
    }
}
pub struct IndicatorLineActionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IndicatorLineActionBuilder<'a, 'b> {
  #[inline]
  pub fn add_start_loc(&mut self, start_loc: u16) {
    self.fbb_.push_slot::<u16>(IndicatorLineAction::VT_START_LOC, start_loc, 0);
  }
  #[inline]
  pub fn add_end_loc(&mut self, end_loc: u16) {
    self.fbb_.push_slot::<u16>(IndicatorLineAction::VT_END_LOC, end_loc, 0);
  }
  #[inline]
  pub fn add_color_hex(&mut self, color_hex: i32) {
    self.fbb_.push_slot::<i32>(IndicatorLineAction::VT_COLOR_HEX, color_hex, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IndicatorLineActionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IndicatorLineActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IndicatorLineAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for IndicatorLineAction<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("IndicatorLineAction");
      ds.field("start_loc", &self.start_loc());
      ds.field("end_loc", &self.end_loc());
      ds.field("color_hex", &self.color_hex());
      ds.finish()
  }
}
pub enum InitialBodyTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InitialBodyTable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InitialBodyTable<'a> {
    type Inner = InitialBodyTable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> InitialBodyTable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InitialBodyTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InitialBodyTableArgs<'args>) -> flatbuffers::WIPOffset<InitialBodyTable<'bldr>> {
      let mut builder = InitialBodyTableBuilder::new(_fbb);
      if let Some(x) = args.spawn_actions { builder.add_spawn_actions(x); }
      builder.finish()
    }

    pub const VT_SPAWN_ACTIONS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn spawn_actions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SpawnAction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SpawnAction>>>>(InitialBodyTable::VT_SPAWN_ACTIONS, None)
  }
}

impl flatbuffers::Verifiable for InitialBodyTable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SpawnAction>>>>(&"spawn_actions", Self::VT_SPAWN_ACTIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct InitialBodyTableArgs<'a> {
    pub spawn_actions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SpawnAction<'a>>>>>,
}
impl<'a> Default for InitialBodyTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        InitialBodyTableArgs {
            spawn_actions: None,
        }
    }
}
pub struct InitialBodyTableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InitialBodyTableBuilder<'a, 'b> {
  #[inline]
  pub fn add_spawn_actions(&mut self, spawn_actions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SpawnAction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InitialBodyTable::VT_SPAWN_ACTIONS, spawn_actions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InitialBodyTableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InitialBodyTableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InitialBodyTable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for InitialBodyTable<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("InitialBodyTable");
      ds.field("spawn_actions", &self.spawn_actions());
      ds.finish()
  }
}
pub enum GameMapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GameMap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GameMap<'a> {
    type Inner = GameMap<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> GameMap<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GameMap { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GameMapArgs<'args>) -> flatbuffers::WIPOffset<GameMap<'bldr>> {
      let mut builder = GameMapBuilder::new(_fbb);
      if let Some(x) = args.paint_patterns { builder.add_paint_patterns(x); }
      if let Some(x) = args.ruins { builder.add_ruins(x); }
      if let Some(x) = args.paint { builder.add_paint(x); }
      if let Some(x) = args.walls { builder.add_walls(x); }
      builder.add_random_seed(args.random_seed);
      if let Some(x) = args.initial_bodies { builder.add_initial_bodies(x); }
      builder.add_symmetry(args.symmetry);
      if let Some(x) = args.size_ { builder.add_size_(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 6;
    pub const VT_SYMMETRY: flatbuffers::VOffsetT = 8;
    pub const VT_INITIAL_BODIES: flatbuffers::VOffsetT = 10;
    pub const VT_RANDOM_SEED: flatbuffers::VOffsetT = 12;
    pub const VT_WALLS: flatbuffers::VOffsetT = 14;
    pub const VT_PAINT: flatbuffers::VOffsetT = 16;
    pub const VT_RUINS: flatbuffers::VOffsetT = 18;
    pub const VT_PAINT_PATTERNS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GameMap::VT_NAME, None)
  }
  #[inline]
  pub fn size_(&self) -> Option<&'a Vec> {
    self._tab.get::<Vec>(GameMap::VT_SIZE_, None)
  }
  #[inline]
  pub fn symmetry(&self) -> i32 {
    self._tab.get::<i32>(GameMap::VT_SYMMETRY, Some(0)).unwrap()
  }
  #[inline]
  pub fn initial_bodies(&self) -> Option<InitialBodyTable<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<InitialBodyTable>>(GameMap::VT_INITIAL_BODIES, None)
  }
  #[inline]
  pub fn random_seed(&self) -> i32 {
    self._tab.get::<i32>(GameMap::VT_RANDOM_SEED, Some(0)).unwrap()
  }
  #[inline]
  pub fn walls(&self) -> Option<&'a [bool]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(GameMap::VT_WALLS, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn paint(&self) -> Option<&'a [i8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(GameMap::VT_PAINT, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn ruins(&self) -> Option<VecTable<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<VecTable>>(GameMap::VT_RUINS, None)
  }
  #[inline]
  pub fn paint_patterns(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(GameMap::VT_PAINT_PATTERNS, None)
  }
}

impl flatbuffers::Verifiable for GameMap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_field::<Vec>(&"size_", Self::VT_SIZE_, false)?
     .visit_field::<i32>(&"symmetry", Self::VT_SYMMETRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<InitialBodyTable>>(&"initial_bodies", Self::VT_INITIAL_BODIES, false)?
     .visit_field::<i32>(&"random_seed", Self::VT_RANDOM_SEED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>(&"walls", Self::VT_WALLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(&"paint", Self::VT_PAINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VecTable>>(&"ruins", Self::VT_RUINS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"paint_patterns", Self::VT_PAINT_PATTERNS, false)?
     .finish();
    Ok(())
  }
}
pub struct GameMapArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub size_: Option<&'a Vec>,
    pub symmetry: i32,
    pub initial_bodies: Option<flatbuffers::WIPOffset<InitialBodyTable<'a>>>,
    pub random_seed: i32,
    pub walls: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub paint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
    pub ruins: Option<flatbuffers::WIPOffset<VecTable<'a>>>,
    pub paint_patterns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for GameMapArgs<'a> {
    #[inline]
    fn default() -> Self {
        GameMapArgs {
            name: None,
            size_: None,
            symmetry: 0,
            initial_bodies: None,
            random_seed: 0,
            walls: None,
            paint: None,
            ruins: None,
            paint_patterns: None,
        }
    }
}
pub struct GameMapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GameMapBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameMap::VT_NAME, name);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: &Vec) {
    self.fbb_.push_slot_always::<&Vec>(GameMap::VT_SIZE_, size_);
  }
  #[inline]
  pub fn add_symmetry(&mut self, symmetry: i32) {
    self.fbb_.push_slot::<i32>(GameMap::VT_SYMMETRY, symmetry, 0);
  }
  #[inline]
  pub fn add_initial_bodies(&mut self, initial_bodies: flatbuffers::WIPOffset<InitialBodyTable<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<InitialBodyTable>>(GameMap::VT_INITIAL_BODIES, initial_bodies);
  }
  #[inline]
  pub fn add_random_seed(&mut self, random_seed: i32) {
    self.fbb_.push_slot::<i32>(GameMap::VT_RANDOM_SEED, random_seed, 0);
  }
  #[inline]
  pub fn add_walls(&mut self, walls: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameMap::VT_WALLS, walls);
  }
  #[inline]
  pub fn add_paint(&mut self, paint: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameMap::VT_PAINT, paint);
  }
  #[inline]
  pub fn add_ruins(&mut self, ruins: flatbuffers::WIPOffset<VecTable<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VecTable>>(GameMap::VT_RUINS, ruins);
  }
  #[inline]
  pub fn add_paint_patterns(&mut self, paint_patterns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameMap::VT_PAINT_PATTERNS, paint_patterns);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GameMapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GameMapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GameMap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for GameMap<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("GameMap");
      ds.field("name", &self.name());
      ds.field("size_", &self.size_());
      ds.field("symmetry", &self.symmetry());
      ds.field("initial_bodies", &self.initial_bodies());
      ds.field("random_seed", &self.random_seed());
      ds.field("walls", &self.walls());
      ds.field("paint", &self.paint());
      ds.field("ruins", &self.ruins());
      ds.field("paint_patterns", &self.paint_patterns());
      ds.finish()
  }
}
pub enum TimelineMarkerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Markers for events during the game indicated by the user
pub struct TimelineMarker<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimelineMarker<'a> {
    type Inner = TimelineMarker<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TimelineMarker<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TimelineMarker { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TimelineMarkerArgs<'args>) -> flatbuffers::WIPOffset<TimelineMarker<'bldr>> {
      let mut builder = TimelineMarkerBuilder::new(_fbb);
      if let Some(x) = args.label { builder.add_label(x); }
      builder.add_color_hex(args.color_hex);
      builder.add_round(args.round);
      builder.add_team(args.team);
      builder.finish()
    }

    pub const VT_TEAM: flatbuffers::VOffsetT = 4;
    pub const VT_ROUND: flatbuffers::VOffsetT = 6;
    pub const VT_COLOR_HEX: flatbuffers::VOffsetT = 8;
    pub const VT_LABEL: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn team(&self) -> i8 {
    self._tab.get::<i8>(TimelineMarker::VT_TEAM, Some(0)).unwrap()
  }
  #[inline]
  pub fn round(&self) -> i32 {
    self._tab.get::<i32>(TimelineMarker::VT_ROUND, Some(0)).unwrap()
  }
  #[inline]
  pub fn color_hex(&self) -> i32 {
    self._tab.get::<i32>(TimelineMarker::VT_COLOR_HEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TimelineMarker::VT_LABEL, None)
  }
}

impl flatbuffers::Verifiable for TimelineMarker<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>(&"team", Self::VT_TEAM, false)?
     .visit_field::<i32>(&"round", Self::VT_ROUND, false)?
     .visit_field::<i32>(&"color_hex", Self::VT_COLOR_HEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"label", Self::VT_LABEL, false)?
     .finish();
    Ok(())
  }
}
pub struct TimelineMarkerArgs<'a> {
    pub team: i8,
    pub round: i32,
    pub color_hex: i32,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TimelineMarkerArgs<'a> {
    #[inline]
    fn default() -> Self {
        TimelineMarkerArgs {
            team: 0,
            round: 0,
            color_hex: 0,
            label: None,
        }
    }
}
pub struct TimelineMarkerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TimelineMarkerBuilder<'a, 'b> {
  #[inline]
  pub fn add_team(&mut self, team: i8) {
    self.fbb_.push_slot::<i8>(TimelineMarker::VT_TEAM, team, 0);
  }
  #[inline]
  pub fn add_round(&mut self, round: i32) {
    self.fbb_.push_slot::<i32>(TimelineMarker::VT_ROUND, round, 0);
  }
  #[inline]
  pub fn add_color_hex(&mut self, color_hex: i32) {
    self.fbb_.push_slot::<i32>(TimelineMarker::VT_COLOR_HEX, color_hex, 0);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TimelineMarker::VT_LABEL, label);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimelineMarkerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TimelineMarkerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimelineMarker<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TimelineMarker<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TimelineMarker");
      ds.field("team", &self.team());
      ds.field("round", &self.round());
      ds.field("color_hex", &self.color_hex());
      ds.field("label", &self.label());
      ds.finish()
  }
}
pub enum ProfilerEventOffset {}
#[derive(Copy, Clone, PartialEq)]

/// These tables are set-up so that they match closely with speedscope's file format documented at
/// https://github.com/jlfwong/speedscope/wiki/Importing-from-custom-sources.
/// The client uses speedscope to show the recorded data in an interactive interface.
/// A single event in a profile. Represents either an open event (meaning a
/// method has been entered) or a close event (meaning the method was exited).
pub struct ProfilerEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProfilerEvent<'a> {
    type Inner = ProfilerEvent<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ProfilerEvent<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ProfilerEvent { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ProfilerEventArgs) -> flatbuffers::WIPOffset<ProfilerEvent<'bldr>> {
      let mut builder = ProfilerEventBuilder::new(_fbb);
      builder.add_frame(args.frame);
      builder.add_at(args.at);
      builder.add_is_open(args.is_open);
      builder.finish()
    }

    pub const VT_IS_OPEN: flatbuffers::VOffsetT = 4;
    pub const VT_AT: flatbuffers::VOffsetT = 6;
    pub const VT_FRAME: flatbuffers::VOffsetT = 8;

  /// Whether this is an open event (true) or a close event (false).
  #[inline]
  pub fn is_open(&self) -> bool {
    self._tab.get::<bool>(ProfilerEvent::VT_IS_OPEN, Some(false)).unwrap()
  }
  /// The bytecode counter at the time the event occurred.
  #[inline]
  pub fn at(&self) -> i32 {
    self._tab.get::<i32>(ProfilerEvent::VT_AT, Some(0)).unwrap()
  }
  /// The index of the method name in the ProfilerFile.frames array.
  #[inline]
  pub fn frame(&self) -> i32 {
    self._tab.get::<i32>(ProfilerEvent::VT_FRAME, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for ProfilerEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>(&"is_open", Self::VT_IS_OPEN, false)?
     .visit_field::<i32>(&"at", Self::VT_AT, false)?
     .visit_field::<i32>(&"frame", Self::VT_FRAME, false)?
     .finish();
    Ok(())
  }
}
pub struct ProfilerEventArgs {
    pub is_open: bool,
    pub at: i32,
    pub frame: i32,
}
impl<'a> Default for ProfilerEventArgs {
    #[inline]
    fn default() -> Self {
        ProfilerEventArgs {
            is_open: false,
            at: 0,
            frame: 0,
        }
    }
}
pub struct ProfilerEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ProfilerEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_is_open(&mut self, is_open: bool) {
    self.fbb_.push_slot::<bool>(ProfilerEvent::VT_IS_OPEN, is_open, false);
  }
  #[inline]
  pub fn add_at(&mut self, at: i32) {
    self.fbb_.push_slot::<i32>(ProfilerEvent::VT_AT, at, 0);
  }
  #[inline]
  pub fn add_frame(&mut self, frame: i32) {
    self.fbb_.push_slot::<i32>(ProfilerEvent::VT_FRAME, frame, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProfilerEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ProfilerEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProfilerEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ProfilerEvent<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ProfilerEvent");
      ds.field("is_open", &self.is_open());
      ds.field("at", &self.at());
      ds.field("frame", &self.frame());
      ds.finish()
  }
}
pub enum ProfilerProfileOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A profile contains all events and is labeled with a name.
pub struct ProfilerProfile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProfilerProfile<'a> {
    type Inner = ProfilerProfile<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ProfilerProfile<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ProfilerProfile { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ProfilerProfileArgs<'args>) -> flatbuffers::WIPOffset<ProfilerProfile<'bldr>> {
      let mut builder = ProfilerProfileBuilder::new(_fbb);
      if let Some(x) = args.events { builder.add_events(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_EVENTS: flatbuffers::VOffsetT = 6;

  /// The display-friendly name of the profile.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProfilerProfile::VT_NAME, None)
  }
  /// The events that occurred in the profile.
  #[inline]
  pub fn events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerEvent<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerEvent>>>>(ProfilerProfile::VT_EVENTS, None)
  }
}

impl flatbuffers::Verifiable for ProfilerProfile<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProfilerEvent>>>>(&"events", Self::VT_EVENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct ProfilerProfileArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerEvent<'a>>>>>,
}
impl<'a> Default for ProfilerProfileArgs<'a> {
    #[inline]
    fn default() -> Self {
        ProfilerProfileArgs {
            name: None,
            events: None,
        }
    }
}
pub struct ProfilerProfileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ProfilerProfileBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProfilerProfile::VT_NAME, name);
  }
  #[inline]
  pub fn add_events(&mut self, events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProfilerEvent<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProfilerProfile::VT_EVENTS, events);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProfilerProfileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ProfilerProfileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProfilerProfile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ProfilerProfile<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ProfilerProfile");
      ds.field("name", &self.name());
      ds.field("events", &self.events());
      ds.finish()
  }
}
pub enum ProfilerFileOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A profiler file is a collection of profiles.
/// When profiling is enabled there is one of these per team per match.
pub struct ProfilerFile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProfilerFile<'a> {
    type Inner = ProfilerFile<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ProfilerFile<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ProfilerFile { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ProfilerFileArgs<'args>) -> flatbuffers::WIPOffset<ProfilerFile<'bldr>> {
      let mut builder = ProfilerFileBuilder::new(_fbb);
      if let Some(x) = args.profiles { builder.add_profiles(x); }
      if let Some(x) = args.frames { builder.add_frames(x); }
      builder.finish()
    }

    pub const VT_FRAMES: flatbuffers::VOffsetT = 4;
    pub const VT_PROFILES: flatbuffers::VOffsetT = 6;

  /// The method names that are referred to in the events.
  #[inline]
  pub fn frames(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ProfilerFile::VT_FRAMES, None)
  }
  /// The recorded profiles, one per robot.
  #[inline]
  pub fn profiles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerProfile<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerProfile>>>>(ProfilerFile::VT_PROFILES, None)
  }
}

impl flatbuffers::Verifiable for ProfilerFile<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>(&"frames", Self::VT_FRAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProfilerProfile>>>>(&"profiles", Self::VT_PROFILES, false)?
     .finish();
    Ok(())
  }
}
pub struct ProfilerFileArgs<'a> {
    pub frames: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub profiles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerProfile<'a>>>>>,
}
impl<'a> Default for ProfilerFileArgs<'a> {
    #[inline]
    fn default() -> Self {
        ProfilerFileArgs {
            frames: None,
            profiles: None,
        }
    }
}
pub struct ProfilerFileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ProfilerFileBuilder<'a, 'b> {
  #[inline]
  pub fn add_frames(&mut self, frames: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProfilerFile::VT_FRAMES, frames);
  }
  #[inline]
  pub fn add_profiles(&mut self, profiles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProfilerProfile<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProfilerFile::VT_PROFILES, profiles);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProfilerFileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ProfilerFileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProfilerFile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ProfilerFile<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ProfilerFile");
      ds.field("frames", &self.frames());
      ds.field("profiles", &self.profiles());
      ds.finish()
  }
}
pub enum GameHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The first event sent in the game. Contains all metadata about the game.
pub struct GameHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GameHeader<'a> {
    type Inner = GameHeader<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> GameHeader<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GameHeader { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GameHeaderArgs<'args>) -> flatbuffers::WIPOffset<GameHeader<'bldr>> {
      let mut builder = GameHeaderBuilder::new(_fbb);
      if let Some(x) = args.constants { builder.add_constants(x); }
      if let Some(x) = args.robot_type_metadata { builder.add_robot_type_metadata(x); }
      if let Some(x) = args.teams { builder.add_teams(x); }
      if let Some(x) = args.spec_version { builder.add_spec_version(x); }
      builder.finish()
    }

    pub const VT_SPEC_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_TEAMS: flatbuffers::VOffsetT = 6;
    pub const VT_ROBOT_TYPE_METADATA: flatbuffers::VOffsetT = 8;
    pub const VT_CONSTANTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn spec_version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GameHeader::VT_SPEC_VERSION, None)
  }
  #[inline]
  pub fn teams(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamData<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamData>>>>(GameHeader::VT_TEAMS, None)
  }
  #[inline]
  pub fn robot_type_metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RobotTypeMetadata<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RobotTypeMetadata>>>>(GameHeader::VT_ROBOT_TYPE_METADATA, None)
  }
  #[inline]
  pub fn constants(&self) -> Option<GameplayConstants<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<GameplayConstants>>(GameHeader::VT_CONSTANTS, None)
  }
}

impl flatbuffers::Verifiable for GameHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"spec_version", Self::VT_SPEC_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TeamData>>>>(&"teams", Self::VT_TEAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RobotTypeMetadata>>>>(&"robot_type_metadata", Self::VT_ROBOT_TYPE_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GameplayConstants>>(&"constants", Self::VT_CONSTANTS, false)?
     .finish();
    Ok(())
  }
}
pub struct GameHeaderArgs<'a> {
    pub spec_version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teams: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamData<'a>>>>>,
    pub robot_type_metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RobotTypeMetadata<'a>>>>>,
    pub constants: Option<flatbuffers::WIPOffset<GameplayConstants<'a>>>,
}
impl<'a> Default for GameHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        GameHeaderArgs {
            spec_version: None,
            teams: None,
            robot_type_metadata: None,
            constants: None,
        }
    }
}
pub struct GameHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GameHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_spec_version(&mut self, spec_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameHeader::VT_SPEC_VERSION, spec_version);
  }
  #[inline]
  pub fn add_teams(&mut self, teams: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TeamData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameHeader::VT_TEAMS, teams);
  }
  #[inline]
  pub fn add_robot_type_metadata(&mut self, robot_type_metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RobotTypeMetadata<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameHeader::VT_ROBOT_TYPE_METADATA, robot_type_metadata);
  }
  #[inline]
  pub fn add_constants(&mut self, constants: flatbuffers::WIPOffset<GameplayConstants<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GameplayConstants>>(GameHeader::VT_CONSTANTS, constants);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GameHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GameHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GameHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for GameHeader<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("GameHeader");
      ds.field("spec_version", &self.spec_version());
      ds.field("teams", &self.teams());
      ds.field("robot_type_metadata", &self.robot_type_metadata());
      ds.field("constants", &self.constants());
      ds.finish()
  }
}
pub enum GameFooterOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The final event sent in the game.
pub struct GameFooter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GameFooter<'a> {
    type Inner = GameFooter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> GameFooter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GameFooter { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GameFooterArgs) -> flatbuffers::WIPOffset<GameFooter<'bldr>> {
      let mut builder = GameFooterBuilder::new(_fbb);
      builder.add_winner(args.winner);
      builder.finish()
    }

    pub const VT_WINNER: flatbuffers::VOffsetT = 4;

  /// The ID of the winning team of the game.
  #[inline]
  pub fn winner(&self) -> i8 {
    self._tab.get::<i8>(GameFooter::VT_WINNER, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for GameFooter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>(&"winner", Self::VT_WINNER, false)?
     .finish();
    Ok(())
  }
}
pub struct GameFooterArgs {
    pub winner: i8,
}
impl<'a> Default for GameFooterArgs {
    #[inline]
    fn default() -> Self {
        GameFooterArgs {
            winner: 0,
        }
    }
}
pub struct GameFooterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GameFooterBuilder<'a, 'b> {
  #[inline]
  pub fn add_winner(&mut self, winner: i8) {
    self.fbb_.push_slot::<i8>(GameFooter::VT_WINNER, winner, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GameFooterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GameFooterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GameFooter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for GameFooter<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("GameFooter");
      ds.field("winner", &self.winner());
      ds.finish()
  }
}
pub enum MatchHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sent to start a match.
pub struct MatchHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchHeader<'a> {
    type Inner = MatchHeader<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MatchHeader<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MatchHeader { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MatchHeaderArgs<'args>) -> flatbuffers::WIPOffset<MatchHeader<'bldr>> {
      let mut builder = MatchHeaderBuilder::new(_fbb);
      builder.add_max_rounds(args.max_rounds);
      if let Some(x) = args.map { builder.add_map(x); }
      builder.finish()
    }

    pub const VT_MAP: flatbuffers::VOffsetT = 4;
    pub const VT_MAX_ROUNDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn map(&self) -> Option<GameMap<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<GameMap>>(MatchHeader::VT_MAP, None)
  }
  #[inline]
  pub fn max_rounds(&self) -> i32 {
    self._tab.get::<i32>(MatchHeader::VT_MAX_ROUNDS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for MatchHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<GameMap>>(&"map", Self::VT_MAP, false)?
     .visit_field::<i32>(&"max_rounds", Self::VT_MAX_ROUNDS, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchHeaderArgs<'a> {
    pub map: Option<flatbuffers::WIPOffset<GameMap<'a>>>,
    pub max_rounds: i32,
}
impl<'a> Default for MatchHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        MatchHeaderArgs {
            map: None,
            max_rounds: 0,
        }
    }
}
pub struct MatchHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MatchHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_map(&mut self, map: flatbuffers::WIPOffset<GameMap<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GameMap>>(MatchHeader::VT_MAP, map);
  }
  #[inline]
  pub fn add_max_rounds(&mut self, max_rounds: i32) {
    self.fbb_.push_slot::<i32>(MatchHeader::VT_MAX_ROUNDS, max_rounds, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MatchHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MatchHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MatchHeader<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MatchHeader");
      ds.field("map", &self.map());
      ds.field("max_rounds", &self.max_rounds());
      ds.finish()
  }
}
pub enum MatchFooterOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sent to end a match.
pub struct MatchFooter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchFooter<'a> {
    type Inner = MatchFooter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MatchFooter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MatchFooter { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MatchFooterArgs<'args>) -> flatbuffers::WIPOffset<MatchFooter<'bldr>> {
      let mut builder = MatchFooterBuilder::new(_fbb);
      if let Some(x) = args.profiler_files { builder.add_profiler_files(x); }
      if let Some(x) = args.timeline_markers { builder.add_timeline_markers(x); }
      builder.add_total_rounds(args.total_rounds);
      builder.add_win_type(args.win_type);
      builder.add_winner(args.winner);
      builder.finish()
    }

    pub const VT_WINNER: flatbuffers::VOffsetT = 4;
    pub const VT_WIN_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TOTAL_ROUNDS: flatbuffers::VOffsetT = 8;
    pub const VT_TIMELINE_MARKERS: flatbuffers::VOffsetT = 10;
    pub const VT_PROFILER_FILES: flatbuffers::VOffsetT = 12;

  /// The ID of the winning team.
  #[inline]
  pub fn winner(&self) -> i8 {
    self._tab.get::<i8>(MatchFooter::VT_WINNER, Some(0)).unwrap()
  }
  /// The reason for winning
  #[inline]
  pub fn win_type(&self) -> WinType {
    self._tab.get::<WinType>(MatchFooter::VT_WIN_TYPE, Some(WinType::RESIGNATION)).unwrap()
  }
  /// The number of rounds played.
  #[inline]
  pub fn total_rounds(&self) -> i32 {
    self._tab.get::<i32>(MatchFooter::VT_TOTAL_ROUNDS, Some(0)).unwrap()
  }
  /// Markers for this match.
  #[inline]
  pub fn timeline_markers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TimelineMarker<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TimelineMarker>>>>(MatchFooter::VT_TIMELINE_MARKERS, None)
  }
  /// Profiler data for team A and B if profiling is enabled.
  #[inline]
  pub fn profiler_files(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerFile<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerFile>>>>(MatchFooter::VT_PROFILER_FILES, None)
  }
}

impl flatbuffers::Verifiable for MatchFooter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>(&"winner", Self::VT_WINNER, false)?
     .visit_field::<WinType>(&"win_type", Self::VT_WIN_TYPE, false)?
     .visit_field::<i32>(&"total_rounds", Self::VT_TOTAL_ROUNDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TimelineMarker>>>>(&"timeline_markers", Self::VT_TIMELINE_MARKERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProfilerFile>>>>(&"profiler_files", Self::VT_PROFILER_FILES, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchFooterArgs<'a> {
    pub winner: i8,
    pub win_type: WinType,
    pub total_rounds: i32,
    pub timeline_markers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TimelineMarker<'a>>>>>,
    pub profiler_files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilerFile<'a>>>>>,
}
impl<'a> Default for MatchFooterArgs<'a> {
    #[inline]
    fn default() -> Self {
        MatchFooterArgs {
            winner: 0,
            win_type: WinType::RESIGNATION,
            total_rounds: 0,
            timeline_markers: None,
            profiler_files: None,
        }
    }
}
pub struct MatchFooterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MatchFooterBuilder<'a, 'b> {
  #[inline]
  pub fn add_winner(&mut self, winner: i8) {
    self.fbb_.push_slot::<i8>(MatchFooter::VT_WINNER, winner, 0);
  }
  #[inline]
  pub fn add_win_type(&mut self, win_type: WinType) {
    self.fbb_.push_slot::<WinType>(MatchFooter::VT_WIN_TYPE, win_type, WinType::RESIGNATION);
  }
  #[inline]
  pub fn add_total_rounds(&mut self, total_rounds: i32) {
    self.fbb_.push_slot::<i32>(MatchFooter::VT_TOTAL_ROUNDS, total_rounds, 0);
  }
  #[inline]
  pub fn add_timeline_markers(&mut self, timeline_markers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TimelineMarker<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchFooter::VT_TIMELINE_MARKERS, timeline_markers);
  }
  #[inline]
  pub fn add_profiler_files(&mut self, profiler_files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProfilerFile<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchFooter::VT_PROFILER_FILES, profiler_files);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MatchFooterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MatchFooterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchFooter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MatchFooter<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MatchFooter");
      ds.field("winner", &self.winner());
      ds.field("win_type", &self.win_type());
      ds.field("total_rounds", &self.total_rounds());
      ds.field("timeline_markers", &self.timeline_markers());
      ds.field("profiler_files", &self.profiler_files());
      ds.finish()
  }
}
pub enum ActionWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ActionWrapper<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ActionWrapper<'a> {
    type Inner = ActionWrapper<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ActionWrapper<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ActionWrapper { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ActionWrapperArgs) -> flatbuffers::WIPOffset<ActionWrapper<'bldr>> {
      let mut builder = ActionWrapperBuilder::new(_fbb);
      if let Some(x) = args.action { builder.add_action(x); }
      builder.add_action_type(args.action_type);
      builder.finish()
    }

    pub const VT_ACTION_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ACTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn action_type(&self) -> Action {
    self._tab.get::<Action>(ActionWrapper::VT_ACTION_TYPE, Some(Action::NONE)).unwrap()
  }
  #[inline]
  pub fn action(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ActionWrapper::VT_ACTION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_damage_action(&self) -> Option<DamageAction<'a>> {
    if self.action_type() == Action::DamageAction {
      self.action().map(DamageAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_paint_action(&self) -> Option<PaintAction<'a>> {
    if self.action_type() == Action::PaintAction {
      self.action().map(PaintAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_unpaint_action(&self) -> Option<UnpaintAction<'a>> {
    if self.action_type() == Action::UnpaintAction {
      self.action().map(UnpaintAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_mark_action(&self) -> Option<MarkAction<'a>> {
    if self.action_type() == Action::MarkAction {
      self.action().map(MarkAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_unmark_action(&self) -> Option<UnmarkAction<'a>> {
    if self.action_type() == Action::UnmarkAction {
      self.action().map(UnmarkAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_attack_action(&self) -> Option<AttackAction<'a>> {
    if self.action_type() == Action::AttackAction {
      self.action().map(AttackAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_splash_action(&self) -> Option<SplashAction<'a>> {
    if self.action_type() == Action::SplashAction {
      self.action().map(SplashAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_mop_action(&self) -> Option<MopAction<'a>> {
    if self.action_type() == Action::MopAction {
      self.action().map(MopAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_build_action(&self) -> Option<BuildAction<'a>> {
    if self.action_type() == Action::BuildAction {
      self.action().map(BuildAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_transfer_action(&self) -> Option<TransferAction<'a>> {
    if self.action_type() == Action::TransferAction {
      self.action().map(TransferAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_message_action(&self) -> Option<MessageAction<'a>> {
    if self.action_type() == Action::MessageAction {
      self.action().map(MessageAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_spawn_action(&self) -> Option<SpawnAction<'a>> {
    if self.action_type() == Action::SpawnAction {
      self.action().map(SpawnAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_die_action(&self) -> Option<DieAction<'a>> {
    if self.action_type() == Action::DieAction {
      self.action().map(DieAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_upgrade_action(&self) -> Option<UpgradeAction<'a>> {
    if self.action_type() == Action::UpgradeAction {
      self.action().map(UpgradeAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_indicator_string_action(&self) -> Option<IndicatorStringAction<'a>> {
    if self.action_type() == Action::IndicatorStringAction {
      self.action().map(IndicatorStringAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_indicator_dot_action(&self) -> Option<IndicatorDotAction<'a>> {
    if self.action_type() == Action::IndicatorDotAction {
      self.action().map(IndicatorDotAction::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn action_as_indicator_line_action(&self) -> Option<IndicatorLineAction<'a>> {
    if self.action_type() == Action::IndicatorLineAction {
      self.action().map(IndicatorLineAction::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ActionWrapper<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Action, _>(&"action_type", Self::VT_ACTION_TYPE, &"action", Self::VT_ACTION, false, |key, v, pos| {
        match key {
          Action::DamageAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DamageAction>>("Action::DamageAction", pos),
          Action::PaintAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PaintAction>>("Action::PaintAction", pos),
          Action::UnpaintAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnpaintAction>>("Action::UnpaintAction", pos),
          Action::MarkAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MarkAction>>("Action::MarkAction", pos),
          Action::UnmarkAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnmarkAction>>("Action::UnmarkAction", pos),
          Action::AttackAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AttackAction>>("Action::AttackAction", pos),
          Action::SplashAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplashAction>>("Action::SplashAction", pos),
          Action::MopAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MopAction>>("Action::MopAction", pos),
          Action::BuildAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BuildAction>>("Action::BuildAction", pos),
          Action::TransferAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransferAction>>("Action::TransferAction", pos),
          Action::MessageAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MessageAction>>("Action::MessageAction", pos),
          Action::SpawnAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SpawnAction>>("Action::SpawnAction", pos),
          Action::DieAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DieAction>>("Action::DieAction", pos),
          Action::UpgradeAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UpgradeAction>>("Action::UpgradeAction", pos),
          Action::IndicatorStringAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndicatorStringAction>>("Action::IndicatorStringAction", pos),
          Action::IndicatorDotAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndicatorDotAction>>("Action::IndicatorDotAction", pos),
          Action::IndicatorLineAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IndicatorLineAction>>("Action::IndicatorLineAction", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ActionWrapperArgs {
    pub action_type: Action,
    pub action: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ActionWrapperArgs {
    #[inline]
    fn default() -> Self {
        ActionWrapperArgs {
            action_type: Action::NONE,
            action: None,
        }
    }
}
pub struct ActionWrapperBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ActionWrapperBuilder<'a, 'b> {
  #[inline]
  pub fn add_action_type(&mut self, action_type: Action) {
    self.fbb_.push_slot::<Action>(ActionWrapper::VT_ACTION_TYPE, action_type, Action::NONE);
  }
  #[inline]
  pub fn add_action(&mut self, action: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ActionWrapper::VT_ACTION, action);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ActionWrapperBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ActionWrapperBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ActionWrapper<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ActionWrapper<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ActionWrapper");
      ds.field("action_type", &self.action_type());
      match self.action_type() {
        Action::DamageAction => {
          if let Some(x) = self.action_as_damage_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::PaintAction => {
          if let Some(x) = self.action_as_paint_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::UnpaintAction => {
          if let Some(x) = self.action_as_unpaint_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::MarkAction => {
          if let Some(x) = self.action_as_mark_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::UnmarkAction => {
          if let Some(x) = self.action_as_unmark_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::AttackAction => {
          if let Some(x) = self.action_as_attack_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::SplashAction => {
          if let Some(x) = self.action_as_splash_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::MopAction => {
          if let Some(x) = self.action_as_mop_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::BuildAction => {
          if let Some(x) = self.action_as_build_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::TransferAction => {
          if let Some(x) = self.action_as_transfer_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::MessageAction => {
          if let Some(x) = self.action_as_message_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::SpawnAction => {
          if let Some(x) = self.action_as_spawn_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::DieAction => {
          if let Some(x) = self.action_as_die_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::UpgradeAction => {
          if let Some(x) = self.action_as_upgrade_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::IndicatorStringAction => {
          if let Some(x) = self.action_as_indicator_string_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::IndicatorDotAction => {
          if let Some(x) = self.action_as_indicator_dot_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Action::IndicatorLineAction => {
          if let Some(x) = self.action_as_indicator_line_action() {
            ds.field("action", &x)
          } else {
            ds.field("action", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("action", &x)
        },
      };
      ds.finish()
  }
}
pub enum TurnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Turn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Turn<'a> {
    type Inner = Turn<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Turn<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Turn { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TurnArgs<'args>) -> flatbuffers::WIPOffset<Turn<'bldr>> {
      let mut builder = TurnBuilder::new(_fbb);
      if let Some(x) = args.actions { builder.add_actions(x); }
      builder.add_bytecodes_used(args.bytecodes_used);
      builder.add_action_cooldown(args.action_cooldown);
      builder.add_move_cooldown(args.move_cooldown);
      builder.add_paint(args.paint);
      builder.add_health(args.health);
      builder.add_robot_id(args.robot_id);
      builder.add_y(args.y);
      builder.add_x(args.x);
      builder.finish()
    }

    pub const VT_ROBOT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_HEALTH: flatbuffers::VOffsetT = 6;
    pub const VT_PAINT: flatbuffers::VOffsetT = 8;
    pub const VT_MOVE_COOLDOWN: flatbuffers::VOffsetT = 10;
    pub const VT_ACTION_COOLDOWN: flatbuffers::VOffsetT = 12;
    pub const VT_BYTECODES_USED: flatbuffers::VOffsetT = 14;
    pub const VT_X: flatbuffers::VOffsetT = 16;
    pub const VT_Y: flatbuffers::VOffsetT = 18;
    pub const VT_ACTIONS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn robot_id(&self) -> i32 {
    self._tab.get::<i32>(Turn::VT_ROBOT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn health(&self) -> i32 {
    self._tab.get::<i32>(Turn::VT_HEALTH, Some(0)).unwrap()
  }
  #[inline]
  pub fn paint(&self) -> i32 {
    self._tab.get::<i32>(Turn::VT_PAINT, Some(0)).unwrap()
  }
  #[inline]
  pub fn move_cooldown(&self) -> i32 {
    self._tab.get::<i32>(Turn::VT_MOVE_COOLDOWN, Some(0)).unwrap()
  }
  #[inline]
  pub fn action_cooldown(&self) -> i32 {
    self._tab.get::<i32>(Turn::VT_ACTION_COOLDOWN, Some(0)).unwrap()
  }
  #[inline]
  pub fn bytecodes_used(&self) -> i32 {
    self._tab.get::<i32>(Turn::VT_BYTECODES_USED, Some(0)).unwrap()
  }
  #[inline]
  pub fn x(&self) -> u8 {
    self._tab.get::<u8>(Turn::VT_X, Some(0)).unwrap()
  }
  #[inline]
  pub fn y(&self) -> u8 {
    self._tab.get::<u8>(Turn::VT_Y, Some(0)).unwrap()
  }
  #[inline]
  pub fn actions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ActionWrapper<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ActionWrapper>>>>(Turn::VT_ACTIONS, None)
  }
}

impl flatbuffers::Verifiable for Turn<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>(&"robot_id", Self::VT_ROBOT_ID, false)?
     .visit_field::<i32>(&"health", Self::VT_HEALTH, false)?
     .visit_field::<i32>(&"paint", Self::VT_PAINT, false)?
     .visit_field::<i32>(&"move_cooldown", Self::VT_MOVE_COOLDOWN, false)?
     .visit_field::<i32>(&"action_cooldown", Self::VT_ACTION_COOLDOWN, false)?
     .visit_field::<i32>(&"bytecodes_used", Self::VT_BYTECODES_USED, false)?
     .visit_field::<u8>(&"x", Self::VT_X, false)?
     .visit_field::<u8>(&"y", Self::VT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ActionWrapper>>>>(&"actions", Self::VT_ACTIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct TurnArgs<'a> {
    pub robot_id: i32,
    pub health: i32,
    pub paint: i32,
    pub move_cooldown: i32,
    pub action_cooldown: i32,
    pub bytecodes_used: i32,
    pub x: u8,
    pub y: u8,
    pub actions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ActionWrapper<'a>>>>>,
}
impl<'a> Default for TurnArgs<'a> {
    #[inline]
    fn default() -> Self {
        TurnArgs {
            robot_id: 0,
            health: 0,
            paint: 0,
            move_cooldown: 0,
            action_cooldown: 0,
            bytecodes_used: 0,
            x: 0,
            y: 0,
            actions: None,
        }
    }
}
pub struct TurnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TurnBuilder<'a, 'b> {
  #[inline]
  pub fn add_robot_id(&mut self, robot_id: i32) {
    self.fbb_.push_slot::<i32>(Turn::VT_ROBOT_ID, robot_id, 0);
  }
  #[inline]
  pub fn add_health(&mut self, health: i32) {
    self.fbb_.push_slot::<i32>(Turn::VT_HEALTH, health, 0);
  }
  #[inline]
  pub fn add_paint(&mut self, paint: i32) {
    self.fbb_.push_slot::<i32>(Turn::VT_PAINT, paint, 0);
  }
  #[inline]
  pub fn add_move_cooldown(&mut self, move_cooldown: i32) {
    self.fbb_.push_slot::<i32>(Turn::VT_MOVE_COOLDOWN, move_cooldown, 0);
  }
  #[inline]
  pub fn add_action_cooldown(&mut self, action_cooldown: i32) {
    self.fbb_.push_slot::<i32>(Turn::VT_ACTION_COOLDOWN, action_cooldown, 0);
  }
  #[inline]
  pub fn add_bytecodes_used(&mut self, bytecodes_used: i32) {
    self.fbb_.push_slot::<i32>(Turn::VT_BYTECODES_USED, bytecodes_used, 0);
  }
  #[inline]
  pub fn add_x(&mut self, x: u8) {
    self.fbb_.push_slot::<u8>(Turn::VT_X, x, 0);
  }
  #[inline]
  pub fn add_y(&mut self, y: u8) {
    self.fbb_.push_slot::<u8>(Turn::VT_Y, y, 0);
  }
  #[inline]
  pub fn add_actions(&mut self, actions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ActionWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Turn::VT_ACTIONS, actions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TurnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TurnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Turn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Turn<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Turn");
      ds.field("robot_id", &self.robot_id());
      ds.field("health", &self.health());
      ds.field("paint", &self.paint());
      ds.field("move_cooldown", &self.move_cooldown());
      ds.field("action_cooldown", &self.action_cooldown());
      ds.field("bytecodes_used", &self.bytecodes_used());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("actions", &self.actions());
      ds.finish()
  }
}
pub enum RoundOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A single time-step in a Game, which contains a list of robot turns
pub struct Round<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Round<'a> {
    type Inner = Round<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Round<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Round { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RoundArgs<'args>) -> flatbuffers::WIPOffset<Round<'bldr>> {
      let mut builder = RoundBuilder::new(_fbb);
      builder.add_round_id(args.round_id);
      if let Some(x) = args.died_ids { builder.add_died_ids(x); }
      if let Some(x) = args.turns { builder.add_turns(x); }
      if let Some(x) = args.team_resource_pattern_amounts { builder.add_team_resource_pattern_amounts(x); }
      if let Some(x) = args.team_coverage_amounts { builder.add_team_coverage_amounts(x); }
      if let Some(x) = args.team_resource_aounts { builder.add_team_resource_aounts(x); }
      if let Some(x) = args.team_ids { builder.add_team_ids(x); }
      builder.finish()
    }

    pub const VT_TEAM_IDS: flatbuffers::VOffsetT = 4;
    pub const VT_TEAM_RESOURCE_AOUNTS: flatbuffers::VOffsetT = 6;
    pub const VT_TEAM_COVERAGE_AMOUNTS: flatbuffers::VOffsetT = 8;
    pub const VT_TEAM_RESOURCE_PATTERN_AMOUNTS: flatbuffers::VOffsetT = 10;
    pub const VT_TURNS: flatbuffers::VOffsetT = 12;
    pub const VT_DIED_IDS: flatbuffers::VOffsetT = 14;
    pub const VT_ROUND_ID: flatbuffers::VOffsetT = 16;

  /// The IDs of teams in the Game.
  #[inline]
  pub fn team_ids(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Round::VT_TEAM_IDS, None)
  }
  /// The total amount of resource this round per team
  #[inline]
  pub fn team_resource_aounts(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Round::VT_TEAM_RESOURCE_AOUNTS, None)
  }
  /// The total paint coverage percent per team, mult by 10 (i.e. 70.5% is 705)
  #[inline]
  pub fn team_coverage_amounts(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Round::VT_TEAM_COVERAGE_AMOUNTS, None)
  }
  /// The total number of active resource patterns per team
  #[inline]
  pub fn team_resource_pattern_amounts(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Round::VT_TEAM_RESOURCE_PATTERN_AMOUNTS, None)
  }
  /// Ordered turn data for each robot during the round
  #[inline]
  pub fn turns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Turn<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Turn>>>>(Round::VT_TURNS, None)
  }
  /// The IDs of bodies that died at the end of the round, with no attributable cause.
  #[inline]
  pub fn died_ids(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Round::VT_DIED_IDS, None)
  }
  /// The first sent Round in a match should have index 1. (The starting state,
  /// created by the MatchHeader, can be thought to have index 0.)
  /// It should increase by one for each following round.
  #[inline]
  pub fn round_id(&self) -> i32 {
    self._tab.get::<i32>(Round::VT_ROUND_ID, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Round<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"team_ids", Self::VT_TEAM_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"team_resource_aounts", Self::VT_TEAM_RESOURCE_AOUNTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"team_coverage_amounts", Self::VT_TEAM_COVERAGE_AMOUNTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"team_resource_pattern_amounts", Self::VT_TEAM_RESOURCE_PATTERN_AMOUNTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Turn>>>>(&"turns", Self::VT_TURNS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"died_ids", Self::VT_DIED_IDS, false)?
     .visit_field::<i32>(&"round_id", Self::VT_ROUND_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct RoundArgs<'a> {
    pub team_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub team_resource_aounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub team_coverage_amounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub team_resource_pattern_amounts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub turns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Turn<'a>>>>>,
    pub died_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub round_id: i32,
}
impl<'a> Default for RoundArgs<'a> {
    #[inline]
    fn default() -> Self {
        RoundArgs {
            team_ids: None,
            team_resource_aounts: None,
            team_coverage_amounts: None,
            team_resource_pattern_amounts: None,
            turns: None,
            died_ids: None,
            round_id: 0,
        }
    }
}
pub struct RoundBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RoundBuilder<'a, 'b> {
  #[inline]
  pub fn add_team_ids(&mut self, team_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Round::VT_TEAM_IDS, team_ids);
  }
  #[inline]
  pub fn add_team_resource_aounts(&mut self, team_resource_aounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Round::VT_TEAM_RESOURCE_AOUNTS, team_resource_aounts);
  }
  #[inline]
  pub fn add_team_coverage_amounts(&mut self, team_coverage_amounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Round::VT_TEAM_COVERAGE_AMOUNTS, team_coverage_amounts);
  }
  #[inline]
  pub fn add_team_resource_pattern_amounts(&mut self, team_resource_pattern_amounts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Round::VT_TEAM_RESOURCE_PATTERN_AMOUNTS, team_resource_pattern_amounts);
  }
  #[inline]
  pub fn add_turns(&mut self, turns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Turn<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Round::VT_TURNS, turns);
  }
  #[inline]
  pub fn add_died_ids(&mut self, died_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Round::VT_DIED_IDS, died_ids);
  }
  #[inline]
  pub fn add_round_id(&mut self, round_id: i32) {
    self.fbb_.push_slot::<i32>(Round::VT_ROUND_ID, round_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RoundBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RoundBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Round<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Round<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Round");
      ds.field("team_ids", &self.team_ids());
      ds.field("team_resource_aounts", &self.team_resource_aounts());
      ds.field("team_coverage_amounts", &self.team_coverage_amounts());
      ds.field("team_resource_pattern_amounts", &self.team_resource_pattern_amounts());
      ds.field("turns", &self.turns());
      ds.field("died_ids", &self.died_ids());
      ds.field("round_id", &self.round_id());
      ds.finish()
  }
}
pub enum EventWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Necessary due to flatbuffers requiring unions to be wrapped in tables.
pub struct EventWrapper<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventWrapper<'a> {
    type Inner = EventWrapper<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> EventWrapper<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventWrapper { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EventWrapperArgs) -> flatbuffers::WIPOffset<EventWrapper<'bldr>> {
      let mut builder = EventWrapperBuilder::new(_fbb);
      if let Some(x) = args.e { builder.add_e(x); }
      builder.add_e_type(args.e_type);
      builder.finish()
    }

    pub const VT_E_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_E: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn e_type(&self) -> Event {
    self._tab.get::<Event>(EventWrapper::VT_E_TYPE, Some(Event::NONE)).unwrap()
  }
  #[inline]
  pub fn e(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(EventWrapper::VT_E, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn e_as_game_header(&self) -> Option<GameHeader<'a>> {
    if self.e_type() == Event::GameHeader {
      self.e().map(GameHeader::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn e_as_match_header(&self) -> Option<MatchHeader<'a>> {
    if self.e_type() == Event::MatchHeader {
      self.e().map(MatchHeader::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn e_as_round(&self) -> Option<Round<'a>> {
    if self.e_type() == Event::Round {
      self.e().map(Round::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn e_as_match_footer(&self) -> Option<MatchFooter<'a>> {
    if self.e_type() == Event::MatchFooter {
      self.e().map(MatchFooter::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn e_as_game_footer(&self) -> Option<GameFooter<'a>> {
    if self.e_type() == Event::GameFooter {
      self.e().map(GameFooter::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for EventWrapper<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Event, _>(&"e_type", Self::VT_E_TYPE, &"e", Self::VT_E, false, |key, v, pos| {
        match key {
          Event::GameHeader => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GameHeader>>("Event::GameHeader", pos),
          Event::MatchHeader => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MatchHeader>>("Event::MatchHeader", pos),
          Event::Round => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Round>>("Event::Round", pos),
          Event::MatchFooter => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MatchFooter>>("Event::MatchFooter", pos),
          Event::GameFooter => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GameFooter>>("Event::GameFooter", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct EventWrapperArgs {
    pub e_type: Event,
    pub e: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for EventWrapperArgs {
    #[inline]
    fn default() -> Self {
        EventWrapperArgs {
            e_type: Event::NONE,
            e: None,
        }
    }
}
pub struct EventWrapperBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventWrapperBuilder<'a, 'b> {
  #[inline]
  pub fn add_e_type(&mut self, e_type: Event) {
    self.fbb_.push_slot::<Event>(EventWrapper::VT_E_TYPE, e_type, Event::NONE);
  }
  #[inline]
  pub fn add_e(&mut self, e: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventWrapper::VT_E, e);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EventWrapperBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EventWrapperBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EventWrapper<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for EventWrapper<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("EventWrapper");
      ds.field("e_type", &self.e_type());
      match self.e_type() {
        Event::GameHeader => {
          if let Some(x) = self.e_as_game_header() {
            ds.field("e", &x)
          } else {
            ds.field("e", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::MatchHeader => {
          if let Some(x) = self.e_as_match_header() {
            ds.field("e", &x)
          } else {
            ds.field("e", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::Round => {
          if let Some(x) = self.e_as_round() {
            ds.field("e", &x)
          } else {
            ds.field("e", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::MatchFooter => {
          if let Some(x) = self.e_as_match_footer() {
            ds.field("e", &x)
          } else {
            ds.field("e", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::GameFooter => {
          if let Some(x) = self.e_as_game_footer() {
            ds.field("e", &x)
          } else {
            ds.field("e", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("e", &x)
        },
      };
      ds.finish()
  }
}
pub enum GameWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

/// If events are not otherwise delimited, this wrapper structure
/// allows a game to be stored in a single buffer.
/// The first event will be a GameHeader; the last event will be a GameFooter.
/// matchHeaders[0] is the index of the 0th match header in the event stream,
/// corresponding to matchFooters[0]. These indices allow quick traversal of
/// the file.
pub struct GameWrapper<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GameWrapper<'a> {
    type Inner = GameWrapper<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> GameWrapper<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GameWrapper { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GameWrapperArgs<'args>) -> flatbuffers::WIPOffset<GameWrapper<'bldr>> {
      let mut builder = GameWrapperBuilder::new(_fbb);
      if let Some(x) = args.match_footers { builder.add_match_footers(x); }
      if let Some(x) = args.match_headers { builder.add_match_headers(x); }
      if let Some(x) = args.events { builder.add_events(x); }
      builder.finish()
    }

    pub const VT_EVENTS: flatbuffers::VOffsetT = 4;
    pub const VT_MATCH_HEADERS: flatbuffers::VOffsetT = 6;
    pub const VT_MATCH_FOOTERS: flatbuffers::VOffsetT = 8;

  /// The series of events comprising the game.
  #[inline]
  pub fn events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventWrapper<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventWrapper>>>>(GameWrapper::VT_EVENTS, None)
  }
  /// The indices of the headers of the matches, in order.
  #[inline]
  pub fn match_headers(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(GameWrapper::VT_MATCH_HEADERS, None)
  }
  /// The indices of the footers of the matches, in order.
  #[inline]
  pub fn match_footers(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(GameWrapper::VT_MATCH_FOOTERS, None)
  }
}

impl flatbuffers::Verifiable for GameWrapper<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EventWrapper>>>>(&"events", Self::VT_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"match_headers", Self::VT_MATCH_HEADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"match_footers", Self::VT_MATCH_FOOTERS, false)?
     .finish();
    Ok(())
  }
}
pub struct GameWrapperArgs<'a> {
    pub events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventWrapper<'a>>>>>,
    pub match_headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub match_footers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for GameWrapperArgs<'a> {
    #[inline]
    fn default() -> Self {
        GameWrapperArgs {
            events: None,
            match_headers: None,
            match_footers: None,
        }
    }
}
pub struct GameWrapperBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GameWrapperBuilder<'a, 'b> {
  #[inline]
  pub fn add_events(&mut self, events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EventWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameWrapper::VT_EVENTS, events);
  }
  #[inline]
  pub fn add_match_headers(&mut self, match_headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameWrapper::VT_MATCH_HEADERS, match_headers);
  }
  #[inline]
  pub fn add_match_footers(&mut self, match_footers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameWrapper::VT_MATCH_FOOTERS, match_footers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GameWrapperBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GameWrapperBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GameWrapper<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for GameWrapper<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("GameWrapper");
      ds.field("events", &self.events());
      ds.field("match_headers", &self.match_headers());
      ds.field("match_footers", &self.match_footers());
      ds.finish()
  }
}
}  // pub mod schema
}  // pub mod battlecode

